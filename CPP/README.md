# C++ study page
# purpose
+ C++ 및 OOP 지식 향상
# 교재 : Effective C++
# 기간
+ 8주간 Effective C++ 교재 정독 및 실기 진행
# ITEM LIST
+ item5
  + C++이 자체로 만드는 함수들 조심
  + 암시적으로 생성되는 함수는들은
    + default constructor
    + copy constructor
    + copy assignment constructor
    + distructor
+ item6
  + compiler가 자체로 만들어낸 함수가 필요 없으면 확실히 사용을 금지시키자
    + 자동으로 제공하는 함수를 private으로 선언.
    + Uncopyable과 비슷한 기본 클래스 사용.
+ item7
  + polymorphism class에서 소멸자는 반드시 virtual로 선언
    + 어떤 클래스가 가상함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자로 선언
  + 기본 클래스가 아니거나 polymorphism 형태가 아닌 경우는 가상소멸자를 선언하면 안됨.
+ item8
  + 예외가 소멸자를 떠나지 못하도록 해야 함
    + 소멸자에서는 예외가 빠져나가면 안됨. 만일 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아 낸 후 삼켜 버리든지 프로그램을 끝내든지 해야 함
    + 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(소멸자가 아닌 함수)이어야 함.
+ item9
  + 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말기
    + 생성자 및 소멸자 안에서는 절대로 가상함수를 호출하지 말자!
    + 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로 내려가지 않는다.
+ item10
  + 대입 연산자는 *this의 참조자를 반환하자
    + 대입 연산자는 여러 개가 사슬처럼 엮일 수 있다.
     ```
     int x, y, z;
     x = y = z = 15;
     x = (y = (z = 15)));
     ```
+ item11
  + operator= 에서는 자기대입에 대한 처리가 빠지지 않도록..
    + operator=를 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자.
      + 원본체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사후 맞바꾸기 기법을 써도 된다.
    + 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인
