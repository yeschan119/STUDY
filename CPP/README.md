# C++ study page
# purpose
+ C++ 및 OOP 지식 향상
# 교재 : Effective C++ Third Edition by Scott Meyers
# 기간
+ 8주간 Effective C++ 교재 정독 및 실기 진행
# ITEM LIST
+ item5
  + C++이 자체로 만드는 함수들 조심
  + 암시적으로 생성되는 함수는들은
    + default constructor
    + copy constructor
    + copy assignment constructor
    + distructor
+ item6
  + compiler가 자체로 만들어낸 함수가 필요 없으면 확실히 사용을 금지시키자
    + 자동으로 제공하는 함수를 private으로 선언.
    + Uncopyable과 비슷한 기본 클래스 사용.
+ item7
  + polymorphism class에서 소멸자는 반드시 virtual로 선언
    + 어떤 클래스가 가상함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자로 선언
  + 기본 클래스가 아니거나 polymorphism 형태가 아닌 경우는 가상소멸자를 선언하면 안됨.
+ item8
  + 예외가 소멸자를 떠나지 못하도록 해야 함
    + 소멸자에서는 예외가 빠져나가면 안됨. 만일 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아 낸 후 삼켜 버리든지 프로그램을 끝내든지 해야 함
    + 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(소멸자가 아닌 함수)이어야 함.
+ item9
  + 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말기
    + 생성자 및 소멸자 안에서는 절대로 가상함수를 호출하지 말자!
    + 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로 내려가지 않는다.
+ item10
  + 대입 연산자는 *this의 참조자를 반환하자
    + 대입 연산자는 여러 개가 사슬처럼 엮일 수 있다.
     ```
     int x, y, z;
     x = y = z = 15;
     x = (y = (z = 15)));
     ```
+ item11
  + operator= 에서는 자기대입에 대한 처리가 빠지지 않도록..
    + operator=를 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자.
      + 원본체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사후 맞바꾸기 기법을 써도 된다.
    + 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인
+ item12
  + 객체의 모든 부분을 빠짐없이 복사
    + 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 클래스 부분을 빠뜨리지 말고 복사
    + 클래스의 복사 함수 두 개를 구현할 때, 한 쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 말자. 대신 공통된 동작을 제3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결.
+ item13
  + 자원 관리에는 객체를 사용하자
    + 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용
    + 일반적으로 널리 쓰이는 RAII class는 shared_ptr, unique_ptr.
+ item14
  + 자원 관리 클래스의 복사동작에 대해 유의
    + RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제가 따라 다님.
    + 보통 복사를 금지하거나 참조 카운팅을 하는 방법으로 해결
+ item15
  + 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자
    + RAII 클래스를 만들 때는 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 한다.
    + 자원 접근은 명시적 변환 혹은 임시적 변환을 통해 가능하다. 안전성만 따지면 변환이 대체적으로 더 낫지만, 편의성을 보면 암시적 변환이 좋다.
+ item16
  + new, delete를 사용할 때는 형태를 반드시 맞추자
    + new에 []를 썼으면 delete도 []를 사용. 반대도 마찬가지
+ item17
  + new 로 생성한 객체를 스마트 포인터로 넘길 때에는 별도의 문장을 만들어서 넘겨야 함
  + 안그러면 예외 발생시 디버깅하기 힘든 자원 누출 초래
    ```processWidget(std::shared_ptr<Widget>(new Widget), priority());```
    + 위 코드를 수행할 때 shared_ptr는 다음과 같은 순서로 수행(순서는 바뀔 수 있음)
      + 'new Widget' 표현식을 실행하는 부분
      + priority() 실행
      + shared_ptr 생성자를 호출하는 부분
+ item18
  + interface 설계
    + 쓰기 쉽게 만들어야 함
    + 인터페이스 사이의 일관성 잡아주기, 기본제공 타입과의 동작 호환성 유지.
    + 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기.
    + std::shared_ptr는 사용자 정의 삭제자를 지원. 이 특징 때문에 교차 DLL문제를 막아주며, mutex 등을 자동으로 잠금헤제하는 데 쓸 수 있음
+ item19
  + class 설계는 type 설계와 똑같이 취급
    + 클래스 설계는 타입 설계이다. 새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검
+ item20
  + 값에 의한 전달 보다는 상수객체 참조자에 의한 전달 방식을 택해야 함
    + 효율적이면서 복사손실 문제를 해결함
    + STL 반복자, 함수 객체 타입에는 그냥 pass by value 사용
    + 기본적으로 C++는 함수로부터 객체를 전달받거나 전달할 때 pass by value를 사용한다. 이러한 사본을 만들어 내는 원천은 복사 생성자.
    + 이런 방법은 매우 고비용과 복사 손실(slicing problem)문제가 있음.
