# C++ study page
# purpose
+ C++ 및 OOP 지식 향상
# 교재 :
$${\color{red}Effective\space C++\space Third\space Edition}$$ by Scott Meyers
# 기간
+ 8주간 Effective C++ 교재 정독 및 실기 진행
# ITEM LIST
+ item5
  + C++이 자체로 만드는 함수들 조심
  + 암시적으로 생성되는 함수는들은
    + default constructor
    + copy constructor
    + copy assignment constructor
    + distructor
+ item6
  + compiler가 자체로 만들어낸 함수가 필요 없으면 확실히 사용을 금지시키자
    + 자동으로 제공하는 함수를 private으로 선언.
    + Uncopyable과 비슷한 기본 클래스 사용.
+ item7
  + polymorphism class에서 소멸자는 반드시 virtual로 선언
    + 어떤 클래스가 가상함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자로 선언
  + 기본 클래스가 아니거나 polymorphism 형태가 아닌 경우는 가상소멸자를 선언하면 안됨.
+ item8
  + 예외가 소멸자를 떠나지 못하도록 해야 함
    + 소멸자에서는 예외가 빠져나가면 안됨. 만일 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아 낸 후 삼켜 버리든지 프로그램을 끝내든지 해야 함
    + 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(소멸자가 아닌 함수)이어야 함.
+ item9
  + 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말기
    + 생성자 및 소멸자 안에서는 절대로 가상함수를 호출하지 말자!
    + 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로 내려가지 않는다.
+ item10
  + 대입 연산자는 *this의 참조자를 반환하자
    + 대입 연산자는 여러 개가 사슬처럼 엮일 수 있다.
     ```
     int x, y, z;
     x = y = z = 15;
     x = (y = (z = 15)));
     ```
+ item11
  + operator= 에서는 자기대입에 대한 처리가 빠지지 않도록..
    + operator=를 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자.
      + 원본체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사후 맞바꾸기 기법을 써도 된다.
    + 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인
+ item12
  + 객체의 모든 부분을 빠짐없이 복사
    + 객체 복사 함수는 주어진 객체의 모든 데이터 멤버 및 모든 클래스 부분을 빠뜨리지 말고 복사
    + 클래스의 복사 함수 두 개를 구현할 때, 한 쪽을 이용해서 다른 쪽을 구현하려는 시도는 절대로 하지 말자. 대신 공통된 동작을 제3의 함수에다 분리해 놓고 양쪽에서 이것을 호출하게 만들어서 해결.
+ item13
  + 자원 관리에는 객체를 사용하자
    + 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII 객체를 사용
    + 일반적으로 널리 쓰이는 RAII class는 shared_ptr, unique_ptr.
+ item14
  + 자원 관리 클래스의 복사동작에 대해 유의
    + RAII 객체의 복사는 그 객체가 관리하는 자원의 복사 문제가 따라 다님.
    + 보통 복사를 금지하거나 참조 카운팅을 하는 방법으로 해결
+ item15
  + 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자
    + RAII 클래스를 만들 때는 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 한다.
    + 자원 접근은 명시적 변환 혹은 임시적 변환을 통해 가능하다. 안전성만 따지면 변환이 대체적으로 더 낫지만, 편의성을 보면 암시적 변환이 좋다.
+ item16
  + new, delete를 사용할 때는 형태를 반드시 맞추자
    + new에 []를 썼으면 delete도 []를 사용. 반대도 마찬가지
+ item17
  + new 로 생성한 객체를 스마트 포인터로 넘길 때에는 별도의 문장을 만들어서 넘겨야 함
  + 안그러면 예외 발생시 디버깅하기 힘든 자원 누출 초래
    ```processWidget(std::shared_ptr<Widget>(new Widget), priority());```
    + 위 코드를 수행할 때 shared_ptr는 다음과 같은 순서로 수행(순서는 바뀔 수 있음)
      + 'new Widget' 표현식을 실행하는 부분
      + priority() 실행
      + shared_ptr 생성자를 호출하는 부분
+ item18
  + interface 설계
    + 쓰기 쉽게 만들어야 함
    + 인터페이스 사이의 일관성 잡아주기, 기본제공 타입과의 동작 호환성 유지.
    + 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기.
    + std::shared_ptr는 사용자 정의 삭제자를 지원. 이 특징 때문에 교차 DLL문제를 막아주며, mutex 등을 자동으로 잠금헤제하는 데 쓸 수 있음
+ item19
  + class 설계는 type 설계와 똑같이 취급
    + 클래스 설계는 타입 설계이다. 새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검
+ item20
  + 값에 의한 전달 보다는 상수객체 참조자에 의한 전달 방식을 택해야 함
    + 효율적이면서 복사손실 문제를 해결함
    + STL 반복자, 함수 객체 타입에는 그냥 pass by value 사용
    + 기본적으로 C++는 함수로부터 객체를 전달받거나 전달할 때 pass by value를 사용한다. 이러한 사본을 만들어 내는 원천은 복사 생성자.
    + 이런 방법은 매우 고비용과 복사 손실(slicing problem)문제가 있음.
+ item21
  + 함수에서 객체를 반환해야 할 경우 참조자를 반환하지 말자
    + 지역 스택 객체애 대한 포인터나 참조자를 반환하는 일
    + 힙에 할당된 객체에 대한 참조자를 반환하는 일
    + 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일
    + 위와 같은 객체가 두 개 이상 필요해질 가능성이 있다면 참조자로 반환하지 말자
+ item22
  + 데이터 멤버가 선언될 것은 무조건 private 영역이다.
    + 문법적 일관성
    + 데이터 멤버의 접근성을 세밀하게 제어할 수 있음
    + 캡슐화(encapsulation)
+ item23
  + 멤버함수 보는 비멤버 비프렌드 함수 사용
    + 비멤버 함수를 사용하면 좋은점
      + 캡슐화 정도가 높고, 패키징 유연성이 커지고, 기능적인 확정성도 높음.
      + 위 내용은 비프렌드 함수에만 적용
      + 비프렌드 함수는 캠슐화에 영향을 끼칠 것이기 때문.
      + namespace 사용하면 확장성이 높아짐
+ item24
  + 다양한 연산을 하려면 비멤버 함수를 사용
+ item25
  + 예외를 던지지 않는 SWAP에 대한 지원
  + std::swap이 사용자 정의 타입에 대해 느리게 동작할 여지가 있다면 swap멤버 함수 제공
  + std::swap의 경우 복사 생성자와 복사대입 연산자를 호출하므로 느림
+ item26
  + 변수 정의는 늦출 수 있을 때까지 늦추는 근성 발휘
    + 미리 선언했다가 중간에 에러 나면 사용이 안됨...
+ item27
  + casting은 웬만하면 피하기. 특히 dynamic_cast는 신중. 수행성능에 안좋음
  + 피할 수 없으면 함수 안에 숨기거나 C++ 스타일 선호
    + const_cast : 객체의 상수성(constness)를 없애는 용도로 사용
    + dynamic_cast : 안전한 다운캐스팅(safe downcasting)을 할 때 사용함. 런타임 비용이 높다.
    + reinterpret_cast : 포인터를 int로 바꾸는 등의 하부 수준 캐스팅을 위해 만들어진 연산자로, 적용 결과가 구현환경에 의존적.
    + static_cast : 암시적 변환(비상수 객체를 상수 객체로, 혹은 int를 double로 등)을 강제로 진행할 때 사용. 타입 변환을 거꾸로 수행하는 용도로도 쓰임.(void *를 일반 타입의 포인터로)
+ item28
  + 어떤 객체의 내부요소에 대한 핸들(참조자, 포인터, 반복자) 를 반환하는 것은 조심하면
    + 캡슐화 정도를 높이고
    + 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작할 수 있고
    + 무효참조 핸들이 생기는 경우를 최소화할 수 있음
+ item29
  + 예외 안전성은 잘 확보하자
    + 기본적인 보장(basic garantee) 함수 동작 중에 예외가 발생하면 실행 중인 프로그램에 관련된 모든 것들을 유효한 상태로 유지.
    + 강력한 보장(strong guarantee) 함수가 성공적으로 실행을 마친 후의 상태와 함수가 호출될 때의 상태만이 존재할 수 있다.
    + 예외불가 보장(nothrow guarantee) 예외를 던지지 않겠다는 보장. 약속한 동작은 언제나 끝까지 완수하는 함수라는 뜻.
+ item30
  + inline 함수는 정확히 알고 사용하자.
    + inline은 컴파일러에 대해 '요청'을 하는 것이지 '명령'이 아니다. 즉 inline을 붙이지 않아도 그냥 되는 경우도 있고, 명시해도 안되는 경우도 있다.
    + C++에서의 함수 호출 과정
      + 함수가 호출되면 우선 스택에 함수로 전달할 매개변수와 함께 호출이 끝난 뒤 돌아갈 반환 주소값을 저장.
      + 그리고서 프로그램의 제어가 함수의 위치로 넘어와 함수 내에 선언된 지역 변수도 스택에 저장.
      + 그때부터 함수의 모든 코드를 실행하게 되고, 실행이 전부 끝나면 반환값을 넘김.
      + 그 후 프로그램의 제어는 스택에 저장된 돌아갈 반환 주소값으로 이동하여, 스택에 저장된 함수 호출 정보를 제거.
      + 이와 같은 일련의 함수 호출 과정이 함수마다 일어나게 됨.
    + 인라인 함수(inline function) 사용 이유
      + 위와 같이 C++에서 함수의 호출은 꽤 복잡한 과정을 거치므로, 약간의 시간이 걸리게 됨.
      + 이때 함수를 실행하는 시간이 오래 걸린다면, 함수를 호출하는데 걸리는 시간은 전혀 문제가 되지 않지만.
      + 하지만 함수의 실행 시간이 매우 짧다면, 함수 호출에 걸리는 시간도 부담이 될 수 있음.
    + 인라인 함수(inline function)
      + C++에서는 이러한 경우에 사용할 수 있는 인라인 함수(inline function)라는 것을 제공.
      + 인라인 함수는 호출될 때 일반적인 함수의 호출 과정을 거치지 않고, 함수의 모든 코드를 호출된 자리에 바로 삽입하는 방식의 함수.
      + 이 방식은 함수를 호출하는 데 걸리는 시간은 절약되나, 함수 호출 과정으로 생기는 여러 이점을 포기하게 됨.
      + 따라서 코드가 매우 적은 함수만을 인라인 함수로 선언하는 것이 좋다.
+ item31
  + 파일 사이의 컴파일 의존성을 최대로 줄이자.
+ item32
  + public 상속 모형은 반드시 "is-a(...는 ...의 일종이다)"를 따르도록 만들자
    + 어떤 Base 클래스로부터 Derived 클래스가 public 상속을 받았다면, Derived 클래스는 Base 클래스보다 더 특수한 개념을 나타내게 된다. 사용처의 제한
    + public 상속이 신기한 이유는, 우리가 일반적으로 생각하고 있는 논리적인 개념과 충돌할 수 있기 때문이다.
+ item33
  + 상속된 이름은 숨기지 말자
    + 파생 클래스의 이름은 기본 클래스의 이름을 가린다.
    + public 상속에서는 이런 이름 가림 현상은 바람직하지 않다.
    + 가려진 이름을 다시 볼 수 있게 하는 방법으로, using 선언 혹은 전달 함수를 쓸 수 있다.
+ item34
  + interface 상속과 구현 상속의 차이를 제대로 알고 사용
    + 순수 가상 함수를 선언하는 목적은 파생 클래스에게 함수의 인터페이스만을 물려주려는 것.
      + 순수가상함수는 파생 클래스에서 새롭게 정의되어야 함
    + 가상함수는 파생 클래스로 하여금 함수의 인터페이스뿐만 아니라 그 함수의 기본 구현도 물려받게 하자는 것, 즉 직접 구현해야 하지만 귀찮으면 부모 클래스에 있는 것 써라
    + 비가상 함수는 클래스 파생에 상관 없이 변하지 않는 동작을 지정
      + 비가상 함수를 선언하는 목적은 함수 인터페이스와 더불어 그 함수의 필수적인 구현을 물려받게 하는 것.
  + 클래스를 설계할 때 모든 함수를 가상함수로 만들거나 모든 함수를 비가상 함수로 만드는 실수를 하지 않도록
+ item35
  + 가상함수 대신 쓸 수 있는 방법들
    + 비가상 인터페이스 관용구(NVI 관용구)
    + 가상 함수를 함수 포인터 데이터 멤버로 대체
    + 가상 함수를 std::function 데이터 멤버로 대체
    + 전통적인 전략 패턴 사용(다른 쪽 계통에 속해 있는 가상함수로 대체)
+ item36
  + 상속받은 비가상 함수를 다시 재정의 하는 어리적은 짓은 하지 말자
  + 상속받은 클래스는 부모 클래스의 비가상 함수를 재정의 할 경우 그대로 재현해야 하므로 쓸모 없음
+ item37
  + 어떤 함수에 대해서도 상속받은 기본 매개 변수 값은 절대로 재정의 하지 말자
  + 이유는 override 할 때 함수는 dynamic binding 이지만 그 함수의 매개변수는 static binding이다.(성능을 위해서)
+ item38
  + "has-a(...는...를 가짐)" 혹은 "is-implemented-in-terms-of(...는...를 써서 구현됨)"를 모형화할 때는 객체 합성을 사용하자
  + 객체합성(object composition)의 의미는 public 상속이 가진 의미와 완전히 다르다.
  + 응용 영역에서 객체 합성의 의미는 "has a" 이다. 구현 영역에서 is-implemented-in-terms-of의 의미를 갖는다.
+ item39
  + private 상속은 심사숙고
    + private 상속을 굳이 하는 경우는 비공개 멤버로 접근하거나 가상 함수를 재정의할 경우이다.
    + EBO(Empty Base Optimization) 활성화를 위해 사용
+ item40
  + 다중 상속은 심사숙고해서 사용하자
    + 다중 상속은 단일 상속보다 복잡하다. 새로운 모호성 문제를 일으킬 뿐 아니라 가상 상속이 필요해질 수도 있다.
    + 가상 상속을 쓰면 크기 비용, 속도 비용이 늘어나며 초기화 및 대입 연산의 복잡도가 커진다. 따라서 가상 기본 클래스에는 데이터를 두지 않는 것이 현실적으로 가장 실용적이다.
